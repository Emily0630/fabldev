alpha <- rep(1, length(field_marker))
Beta <- rep(1, length(field_marker))
alpha_pi <- 1
beta_pi <- 1
# Initialize
a <- rep(1, length(field_marker))
if(b_init == T){
b <- hash$ohe %>%
sweep(., 1, hash$total_counts, "*") %>%
colSums()
} else {
b = rep(1, length(field_marker))
}
a_pi <- 1
b_pi <- 1
t <- 1
ratio <- 1
elbo_seq <- vector()
adjustment <- n2 / B
holdout <- sample(1:n2, holdout_size)
while(t <= tmax){
a_sum <- a %>%
split(., field_marker) %>%
sapply(., sum) %>%
digamma(.) %>%
.[field_marker]
a_chunk <- digamma(a) - a_sum
b_sum <- b %>%
split(., field_marker) %>%
sapply(., sum) %>%
digamma(.) %>%
.[field_marker]
b_chunk <- digamma(b) - b_sum
m_p <- ohe %>%
sweep(., 2, a_chunk, "*") %>%
rowSums()
u_p <- ohe %>%
sweep(., 2, b_chunk, "*") %>%
rowSums()
# w_p
weights = m_p - u_p
# phi_single
phi <- exp(digamma(a_pi) - digamma(n1) + weights)
single <- exp(digamma(b_pi))
# Phi_j
batch <- sample(1:n2, B, replace = F)
C <- sapply(batch, function(x){
pattern_counts_by_record[[x]] %*% phi + single
})
# S(Phi)
total_nonmatch <- adjustment * sum(single/ C)
total_counts <- lapply(batch, function(x){
hash$pattern_counts_by_record[[x]]
}) %>%
do.call(rbind, .) %>%
colSums() * adjustment
# N_p(Psi)
K <- sapply(1:P, function(p){
sum(record_counts_by_pattern[[p]][batch]/C)
}) * adjustment
epsilon <- (t + tau) ^ (-k)
AZ <- ohe %>%
sweep(., 1, phi * K, "*") %>%
colSums()
BZ <- ohe %>%
sweep(., 1, total_counts - (phi * K), "*") %>%
colSums()
a <- (1 - epsilon) * a + epsilon * (alpha + AZ)
b <- (1 - epsilon) * b + epsilon * (Beta + BZ)
a_pi <- (1 - epsilon) * a_pi  +
epsilon * (alpha_pi + n2 - total_nonmatch)
b_pi <- (1 - epsilon) * b_pi +
epsilon * (beta_pi + total_nonmatch)
# ELBO
elbo_pieces <- vector(length = 6)
C_holdout <- sapply(holdout, function(x){
pattern_counts_by_record[[x]] %*% phi + single
})
holdout_nonmatch <- n2/holdout_size * sum(single/ C_holdout)
# elbo_pieces[1] <- sapply(seq_along(holdout), function(j){
#   record <- batch[j]
#   sum(pattern_counts_by_record[[record]] * (phi *(weights - log(phi) + log(C[j]))/ C[j] +
#                                          u_p))
# }) %>%
#   sum(.) * adjustment
#
# elbo_pieces[2] <-  single * adjustment * sum(1/C *log(C)) + total_nonmatch * log(n1) -log(n1)*n2
#
elbo_pieces[1] <- sapply(seq_along(holdout), function(j){
record <- holdout[j]
sum(pattern_counts_by_record[[record]] * (phi *(weights - log(phi) + log(C_holdout[j]))/ C_holdout[j] +
u_p))
}) %>%
sum(.) * n2/ holdout_size
elbo_pieces[2] <-  n2/ holdout_size * single * sum(1/C_holdout *log(C_holdout)) + holdout_nonmatch * (log(n1) - log(single)) -log(n1)*n2
elbo_pieces[3] <- lbeta(a_pi, b_pi) - lbeta(alpha_pi, beta_pi)
elbo_pieces[4] <- sapply(list(a, b), function(y){
split(y, field_marker) %>%
sapply(., function(x){
sum(lgamma(x)) - lgamma(sum(x))
})%>%
sum(.)
}) %>%
sum(.)
elbo_pieces[5] <- -sapply(list(alpha, Beta), function(y){
split(y, field_marker) %>%
sapply(., function(x){
sum(lgamma(x)) - lgamma(sum(x))
})%>%
sum(.)
}) %>%
sum(.)
elbo_pieces[6] <- sum((alpha - a) * a_chunk + (Beta - b) * b_chunk)
elbo <- sum(elbo_pieces)
elbo_seq <- c(elbo_seq, elbo)
if(is.null(fixed_iterations)){
if(t %% check_every == 0){
ratio <- abs((elbo_seq[t] - elbo_seq[t - check_every +1])/
elbo_seq[t - check_every +1])
}
if(ratio < threshold){
break
}
}
t <- t + 1
if(t > tmax){
print("Max iterations have passed before convergence")
break
}
if(!is.null(fixed_iterations)){
if(t == fixed_iterations){
break
}
}
}
C <- sapply(1:n2, function(x){
pattern_counts_by_record[[x]] %*% phi + single
})
list(pattern_weights = phi,
C = C,
a = a,
b = b,
a_pi = a_pi,
b_pi = b_pi,
elbo_seq = elbo_seq,
t = t)
tmax
threshold
ratio
threshold
k
svi_efficient(hash, k = 1, B = 1000)
library(fabldev)
library(ggplot2)
n1 <- 50
n2 <- 50
overlap <- n2/2
S = 50
burn = S * .1
show_progress <- T
fast = F
R <- NULL
all_patterns <- FALSE
m <- c(.05, .95, .05, .95, .05, .95, .05, .95, .05, .95)
u <- c(.99, .01, .99, .01,
1 - 1/30, 1/30, 1 - 1/12, 1/12, 1 - 1/15, 1/15)
levels <- c(2, 2, 2, 2, 2)
S <- 1000; burn <- S * .1
m_prior <- u_prior <- rep(1, length(m))
alpha <- beta <- 1
cd <- simulate_comparisons(m, u, levels, n1, n2, overlap)
hash <- hash_comparisons(cd)
Ztrue <- cd$Ztrue
out <- vi_efficient(hash)
results <- vi_estimate_links(out, hash)
multivar_beta <- function(x){
sum(lgamma(x)) - lgamma(sum(x))
}
samps <- 50
alpha <- rep(1, ncol(hash$ohe))
beta <- rep(1, ncol(hash$ohe))
alpha_pi <- 1
beta_pi <- 1
phis <- c(out$pattern_weights, exp(digamma(out$b_pi)))
n2 <- hash$n2
n1 <- hash$n1
P <- nrow(hash$ohe)
field_marker <- hash$field_marker
ohe <- hash$ohe
pattern_probs <- lapply(1:n2, function(j){
c(out$pattern_weights * hash$pattern_counts_by_record[[j]],
exp(digamma(out$b_pi))) / out$C[j]
})
N_p <- hash$total_counts
a <- out$a
b <- out$b
a_split <- split(a, field_marker)
b_split <- split(b, field_marker)
a_pi <- out$a_pi
b_pi <- out$b_pi
alpha_split <- split(alpha, field_marker)
beta_split <- split(beta, field_marker)
# Try seeds 42-44
set.seed(42)
khats <- rep(0, 100)
# Try seeds 42-44
set.seed(42)
khats <- rep(0, 100)
for(j in 1:100){
print(j)
log_ratios <- rep(0, 5000)
for(i in 1:5000){
# fabl parameters
m <- as.vector(unlist(sapply(a_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u <- as.vector(unlist(sapply(b_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
pi <- rbeta(1, a_pi, b_pi)
log_m_p <- ohe %>%
sweep(., 2, log(m), "*") %>%
rowSums()
log_u_p <- ohe %>%
sweep(., 2, log(u), "*") %>%
rowSums()
xi <- sapply(1:n2, function(j){
sample(1:(P+1), 1, F, pattern_probs[[j]])
})
n_p_xi <- xi %>%
factor(., 1:(P+1), 1:(P+1)) %>%
table() %>%
.[-(P+1)] %>%
as.numeric()
n_12_xi <- sum(n_p_xi)
#importance ratio
# log_ratio <- sum(n_p_xi * log_m_p) +
#   sum((N_p - n_p_xi) * log_u_p) +
#   sum((alpha - a) * log(m)) +
#   sum((beta - b) * log(u)) +
#   sum(sapply(a_split, multivar_beta)) +
#   sum(sapply(b_split, multivar_beta)) -
#   sum(sapply(alpha_split, multivar_beta)) -
#   sum(sapply(beta_split, multivar_beta)) +
#   (alpha_pi - a_pi + n_12_xi) * log(pi) +
#   (beta_pi - b_pi + n2 - n_12_xi)  * log(1 - pi) +
#   lbeta(a_pi, b_pi) -
#   lbeta(alpha_pi, beta_pi) -
#   n_12_xi * log(n1) -
#   sum(log(phis)[xi] - log(out$C)) #x_j = 0 is coded as P+1
#
# ratio <- exp(log_ratio)
log_joint <- sum(n_p_xi * log_m_p) +
sum((N_p - n_p_xi) * log_u_p) +
sum((alpha - 1) * log(m)) +
sum((beta - 1) * log(u)) -
sum(sapply(alpha_split, multivar_beta)) -
sum(sapply(beta_split, multivar_beta)) +
(alpha_pi - 1 + n_12_xi) * log(pi) +
(beta_pi - 1 + n2 - n_12_xi)  * log(1 - pi) -
lbeta(alpha_pi, beta_pi) -
n_12_xi * log(n1)
log_var <- sum((a - 1) * log(m)) +
sum((b - 1) * log(u)) -
sum(sapply(a_split, multivar_beta)) -
sum(sapply(b_split, multivar_beta)) +
(a_pi - 1) * log(pi) +
(b_pi - 1) * log(1 - pi) -
lbeta(a_pi, b_pi) +
(n2 - n_12_xi) * digamma(b_pi) +
sum(n_p_xi * log(out$pattern_weights)) -
sum(log(out$C))
log_ratios[i] <- log_joint - log_var
}
out$elbo_seq
mean(log_ratios)
diagnostic <- loo::psis(log_ratios = log_ratios, r_eff = NA)
#diagnostic
khats[j] <- diagnostic$diagnostic$pareto_k
}
hist(khats)
hist(khats)
khats
warnings()
mean(log_ratios)
log_ratios
out$elbo_seq
?loo::psis
n_p_xi
log(out$pattern_weights)
P
j = 1
print(j)
log_ratios <- rep(0, 5000)
log_ratios <- rep(0, 500)
log_ratios <- rep(0, 50)
for(i in 1:50){
# fabl parameters
m <- as.vector(unlist(sapply(a_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u <- as.vector(unlist(sapply(b_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
pi <- rbeta(1, a_pi, b_pi)
log_m_p <- ohe %>%
sweep(., 2, log(m), "*") %>%
rowSums()
log_u_p <- ohe %>%
sweep(., 2, log(u), "*") %>%
rowSums()
xi <- sapply(1:n2, function(j){
sample(1:(P+1), 1, F, pattern_probs[[j]])
})
n_p_xi <- xi %>%
factor(., 1:(P+1), 1:(P+1)) %>%
table() %>%
.[-(P+1)] %>%
as.numeric()
n_12_xi <- sum(n_p_xi)
#importance ratio
# log_ratio <- sum(n_p_xi * log_m_p) +
#   sum((N_p - n_p_xi) * log_u_p) +
#   sum((alpha - a) * log(m)) +
#   sum((beta - b) * log(u)) +
#   sum(sapply(a_split, multivar_beta)) +
#   sum(sapply(b_split, multivar_beta)) -
#   sum(sapply(alpha_split, multivar_beta)) -
#   sum(sapply(beta_split, multivar_beta)) +
#   (alpha_pi - a_pi + n_12_xi) * log(pi) +
#   (beta_pi - b_pi + n2 - n_12_xi)  * log(1 - pi) +
#   lbeta(a_pi, b_pi) -
#   lbeta(alpha_pi, beta_pi) -
#   n_12_xi * log(n1) -
#   sum(log(phis)[xi] - log(out$C)) #x_j = 0 is coded as P+1
#
# ratio <- exp(log_ratio)
log_joint <- sum(n_p_xi * log_m_p) +
sum((N_p - n_p_xi) * log_u_p) +
sum((alpha - 1) * log(m)) +
sum((beta - 1) * log(u)) -
sum(sapply(alpha_split, multivar_beta)) -
sum(sapply(beta_split, multivar_beta)) +
(alpha_pi - 1 + n_12_xi) * log(pi) +
(beta_pi - 1 + n2 - n_12_xi)  * log(1 - pi) -
lbeta(alpha_pi, beta_pi) -
n_12_xi * log(n1)
log_var <- sum((a - 1) * log(m)) +
sum((b - 1) * log(u)) -
sum(sapply(a_split, multivar_beta)) -
sum(sapply(b_split, multivar_beta)) +
(a_pi - 1) * log(pi) +
(b_pi - 1) * log(1 - pi) -
lbeta(a_pi, b_pi) +
(n2 - n_12_xi) * digamma(b_pi) - #changed this to minus
sum(n_p_xi * log(out$pattern_weights)) -
sum(log(out$C))
log_ratios[i] <- log_joint - log_var
}
log_ratios
mean(log_ratios)
diagnostic <- loo::psis(log_ratios = log_ratios, r_eff = NA)
diagnostic$diagnostic$pareto_k
for(j in 1:10){
print(j)
log_ratios <- rep(0, 50)
for(i in 1:50){
# fabl parameters
m <- as.vector(unlist(sapply(a_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u <- as.vector(unlist(sapply(b_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
pi <- rbeta(1, a_pi, b_pi)
log_m_p <- ohe %>%
sweep(., 2, log(m), "*") %>%
rowSums()
log_u_p <- ohe %>%
sweep(., 2, log(u), "*") %>%
rowSums()
xi <- sapply(1:n2, function(j){
sample(1:(P+1), 1, F, pattern_probs[[j]])
})
n_p_xi <- xi %>%
factor(., 1:(P+1), 1:(P+1)) %>%
table() %>%
.[-(P+1)] %>%
as.numeric()
n_12_xi <- sum(n_p_xi)
#importance ratio
# log_ratio <- sum(n_p_xi * log_m_p) +
#   sum((N_p - n_p_xi) * log_u_p) +
#   sum((alpha - a) * log(m)) +
#   sum((beta - b) * log(u)) +
#   sum(sapply(a_split, multivar_beta)) +
#   sum(sapply(b_split, multivar_beta)) -
#   sum(sapply(alpha_split, multivar_beta)) -
#   sum(sapply(beta_split, multivar_beta)) +
#   (alpha_pi - a_pi + n_12_xi) * log(pi) +
#   (beta_pi - b_pi + n2 - n_12_xi)  * log(1 - pi) +
#   lbeta(a_pi, b_pi) -
#   lbeta(alpha_pi, beta_pi) -
#   n_12_xi * log(n1) -
#   sum(log(phis)[xi] - log(out$C)) #x_j = 0 is coded as P+1
#
# ratio <- exp(log_ratio)
log_joint <- sum(n_p_xi * log_m_p) +
sum((N_p - n_p_xi) * log_u_p) +
sum((alpha - 1) * log(m)) +
sum((beta - 1) * log(u)) -
sum(sapply(alpha_split, multivar_beta)) -
sum(sapply(beta_split, multivar_beta)) +
(alpha_pi - 1 + n_12_xi) * log(pi) +
(beta_pi - 1 + n2 - n_12_xi)  * log(1 - pi) -
lbeta(alpha_pi, beta_pi) -
n_12_xi * log(n1)
log_var <- sum((a - 1) * log(m)) +
sum((b - 1) * log(u)) -
sum(sapply(a_split, multivar_beta)) -
sum(sapply(b_split, multivar_beta)) +
(a_pi - 1) * log(pi) +
(b_pi - 1) * log(1 - pi) -
lbeta(a_pi, b_pi) +
(n2 - n_12_xi) * digamma(b_pi) - #changed this to minus
sum(n_p_xi * log(out$pattern_weights)) -
sum(log(out$C))
log_ratios[i] <- log_joint - log_var
}
mean(log_ratios)
diagnostic <- loo::psis(log_ratios = log_ratios, r_eff = NA)
#diagnostic
khats[j] <- diagnostic$diagnostic$pareto_k
}
hist(khats)
khats
for(i in 1:50){
# fabl parameters
m <- as.vector(unlist(sapply(a_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u <- as.vector(unlist(sapply(b_split, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
pi <- rbeta(1, a_pi, b_pi)
log_m_p <- ohe %>%
sweep(., 2, log(m), "*") %>%
rowSums()
log_u_p <- ohe %>%
sweep(., 2, log(u), "*") %>%
rowSums()
xi <- sapply(1:n2, function(j){
sample(1:(P+1), 1, F, pattern_probs[[j]])
})
n_p_xi <- xi %>%
factor(., 1:(P+1), 1:(P+1)) %>%
table() %>%
.[-(P+1)] %>%
as.numeric()
n_12_xi <- sum(n_p_xi)
#importance ratio
# log_ratio <- sum(n_p_xi * log_m_p) +
#   sum((N_p - n_p_xi) * log_u_p) +
#   sum((alpha - a) * log(m)) +
#   sum((beta - b) * log(u)) +
#   sum(sapply(a_split, multivar_beta)) +
#   sum(sapply(b_split, multivar_beta)) -
#   sum(sapply(alpha_split, multivar_beta)) -
#   sum(sapply(beta_split, multivar_beta)) +
#   (alpha_pi - a_pi + n_12_xi) * log(pi) +
#   (beta_pi - b_pi + n2 - n_12_xi)  * log(1 - pi) +
#   lbeta(a_pi, b_pi) -
#   lbeta(alpha_pi, beta_pi) -
#   n_12_xi * log(n1) -
#   sum(log(phis)[xi] - log(out$C)) #x_j = 0 is coded as P+1
#
# ratio <- exp(log_ratio)
log_joint <- sum(n_p_xi * log_m_p) +
sum((N_p - n_p_xi) * log_u_p) +
sum((alpha - 1) * log(m)) +
sum((beta - 1) * log(u)) -
sum(sapply(alpha_split, multivar_beta)) -
sum(sapply(beta_split, multivar_beta)) +
(alpha_pi - 1 + n_12_xi) * log(pi) +
(beta_pi - 1 + n2 - n_12_xi)  * log(1 - pi) -
lbeta(alpha_pi, beta_pi) -
n_12_xi * log(n1)
log_var <- sum((a - 1) * log(m)) +
sum((b - 1) * log(u)) -
sum(sapply(a_split, multivar_beta)) -
sum(sapply(b_split, multivar_beta)) +
(a_pi - 1) * log(pi) +
(b_pi - 1) * log(1 - pi) -
lbeta(a_pi, b_pi) +
(n2 - n_12_xi) * digamma(b_pi) - #changed this to minus
sum(n_p_xi * log(out$pattern_weights)) -
sum(log(out$C))
log_ratios[i] <- log_joint - log_var
}
log_ratios
exp(log_ratios)
diagnostic <- loo::psis(log_ratios = log_ratios, r_eff = NA)
diagnostic$diagnostic$pareto_k
?loo::`pareto-k-diagnostic`
