#   while(flag_2 == 1){
#     index <- ceiling(runif(1) * npj)
#     i <- hash_to_file_1[[j]][[pattern]][index]
#     if(Z_inv[i] == 0){
#       Z[j] <- i
#       Z_pattern[j] <- pattern
#       flag_2 <- 0
#     }
#   }
# }
flag <- 0
}
}
}
if(Z[j] > 0){
L <- L + 1
Z_inv[Z[j]] <- 1
}
}
j = 1
if(Z[j] > 0){
L <- L - 1
Z_inv[Z[j]] <- 0
}
Z[j] <- 0
empty_weight <- (n1 - L) * (n2 - L - 1 + beta) / (L + alpha)
n_current <- counts_by_rec[[j]]
for(k in 1:n2){
if(Z[k] > 0){
ind <- pair_to_pattern[[j]][Z[k]]
n_current[ind] <- n_current[ind] - 1
}
}
temp_weights <- n_current * unique_weights
probs <- c(empty_weight, temp_weights)
pattern <- sample(candidates_P, 1, prob = probs)
if(pattern == 0){
Z[j] <- 0
Z_pattern[j] <- 0
}
else{
mode = "efficient"
mode
mode
for(j in 1:n2){
if(Z[j] > 0){
L <- L - 1
Z_inv[Z[j]] <- 0
}
Z[j] <- 0
empty_weight <- (n1 - L) * (n2 - L - 1 + beta) / (L + alpha)
if(mode == "base"){
available <- which(Z_inv == 0)
temp_weights <- c(empty_weight, unique_weights[pair_to_pattern[[j]][available]])
Z[j] <- sample(c(0, available), 1, prob = temp_weights)
if(Z[j] > 0){
Z_pattern[j] <- pair_to_pattern[[j]][Z[j]]
}
else{
Z_pattern[j] <- 0
}
}
else if(mode == "efficient"){
n_current <- counts_by_rec[[j]]
for(k in 1:n2){
if(Z[k] > 0){
ind <- pair_to_pattern[[j]][Z[k]]
n_current[ind] <- n_current[ind] - 1
}
}
temp_weights <- n_current * unique_weights
probs <- c(empty_weight, temp_weights)
pattern <- sample(candidates_P, 1, prob = probs)
if(pattern == 0){
Z[j] <- 0
Z_pattern[j] <- 0
}
else{
flag_2 <- 1
npj <- counts_by_rec[[j]][pattern]
while(flag_2 == 1){
index <- ceiling(runif(1) * npj)
i <- hash_to_file_1[[j]][[pattern]][index]
if(Z_inv[i] == 0){
Z[j] <- i
Z_pattern[j] <- pattern
flag_2 <- 0
}
}
}
}
else if(mode == "rejection"){
hash_weights <- counts_by_rec[[j]] * unique_weights
probs <- c(empty_weight, hash_weights)
flag <- 1
iter <- 0
while(flag == 1){
pattern <- sample(candidates_P, 1, prob = probs)
if(pattern == 0){
Z[j] <- 0
Z_pattern[j] <- 0
flag <- 0
}
else{
index <- ceiling(runif(1) * counts_by_rec[[j]][pattern])
i <- hash_to_file_1[[j]][[pattern]][index]
if(Z_inv[i] == 0){
Z[j] <- i
Z_pattern[j] <- pattern
flag <- 0
}
}
iter <- iter + 1
if(iter == reject_iter){
# O(n1)
available <- which(Z_inv == 0)
temp_weights <- c(empty_weight, unique_weights[pair_to_pattern[[j]][available]])
Z[j] <- sample(c(0, available), 1, prob = temp_weights)
if(Z[j] > 0){
Z_pattern[j] <- pair_to_pattern[[j]][Z[j]]
}
else{
Z_pattern[j] <- 0
}
# O(n2 + P)
# n_current <- counts_by_rec[[j]]
# for(k in 1:n2){
#   if(Z[k] > 0){
#     ind <- pair_to_pattern[[j]][Z[k]]
#     n_current[ind] <- n_current[ind] - 1
#   }
# }
# temp_weights <- n_current * unique_weights
# probs <- c(empty_weight, temp_weights)
# pattern <- sample(candidates_P, 1, prob = probs)
# if(pattern == 0){
#   Z[j] <- 0
#   Z_pattern[j] <- 0
# }
# else{
#   flag_2 <- 1
#   npj <- counts_by_rec[[j]][pattern]
#   while(flag_2 == 1){
#     index <- ceiling(runif(1) * npj)
#     i <- hash_to_file_1[[j]][[pattern]][index]
#     if(Z_inv[i] == 0){
#       Z[j] <- i
#       Z_pattern[j] <- pattern
#       flag_2 <- 0
#     }
#   }
# }
flag <- 0
}
}
}
if(Z[j] > 0){
L <- L + 1
Z_inv[Z[j]] <- 1
}
}
Z
hash_matches <- factor(Z_pattern, levels = 0:P)
df <- data.frame(hash_matches)
matches <- df %>%
group_by(hash_matches, .drop = F) %>%
count() %>%
filter(hash_matches != 0) %>%
pull()
devtools::load_all(".")
chain <- brl_efficient_serge(hash, S = 50)
devtools::install_github("briankundinger/fabldev")
library(RecordLinkage)
library(glue)
library(tictoc)
library(fabldev)
data <- RecordLinkage::RLdata10000 %>%
mutate(unique_id = RecordLinkage::identity.RLdata10000)
duplicates <- nrow(data) * .1
duplicated_ids <- data %>%
filter(duplicated(unique_id)) %>%
select(unique_id) %>%
pull()
duplicated_records <- data %>%
filter(unique_id %in% duplicated_ids) %>%
arrange(unique_id) %>%
mutate(rn = row_number())
duplicated_1 <- duplicated_records %>%
filter(rn %% 2 == 0)
duplicated_2 <- duplicated_records %>%
filter(rn %% 2 == 1)
non_duplicated_records <- data %>%
filter(!(unique_id %in% duplicated_ids)) %>%
mutate(rn = row_number())
non_duplicated_1 <- non_duplicated_records %>%
filter(rn %% 2 == 0)
non_duplicated_2 <- non_duplicated_records %>%
filter(rn %% 2 == 1)
df1 <- rbind(duplicated_1, non_duplicated_1)
df2 <- rbind(duplicated_2, non_duplicated_2)
n1 <- nrow(df1)
n2 <- nrow(df2)
Z_true <- rep(0, nrow(df1))
Z_true[1:duplicates] <- 1:duplicates
fields <- c(1, 3, 5, 6, 7)
types <- c("lv", "lv", "bi", "bi", "bi")
cd <- compare_records(df1, df2, flds = fields, types = types,
breaks = c(0, .15))
hash <- hash_comparisons(cd, all_patterns = F)
chain <- brl_efficient_serge(hash, S = 50)
chain$Z
chain <- brl_efficient_serge(hash, S = 50, mode = "rejection")
roxygen2::roxygenize()
roxygen2::roxygenize()
getwd()
hash <- readRDS("../vablpaper/out/ncvr/combine/hash")
hash <- readRDS("deprecated/hash_fabl")
library(fabldev)
hash <- readRDS("deprecated/hash")
S <- 3
burn <- 1
m_prior <- 1
u_prior <- 1
n1 <- hash$n1
n2 <- hash$n2
field_marker <- hash$field_marker
unique_patterns <- hash$ohe
pattern_counts <- hash$total_counts
P <- nrow(unique_patterns)
counts_by_rec <- hash$pattern_counts_by_record
hash_to_file_1 <-hash$hash_to_file_1
#candidates_P <- 1:(P+1)
candidates_P <- 0:P
Z.SAMPS <- matrix(0, nrow = n2, ncol = S)
M.SAMPS <- matrix(NA, nrow = length(field_marker), ncol = S)
U.SAMPS <- matrix(NA, nrow = length(field_marker), ncol = S)
L.SAMPS <- vector(length = S)
PI.SAMPS <- vector(length = S)
Z <- rep(0, n2)
L <- 0
m <- u <- rep(0, length(field_marker))
matches <- rep(0,P)
s = 1
AZ <- sweep(unique_patterns, MARGIN = 1, STAT = matches, FUN = "*") %>%
colSums() %>%
unname()
nonmatches <- pattern_counts - matches
BZ <- sweep(unique_patterns, MARGIN = 1, STAT = nonmatches, FUN = "*") %>%
colSums() %>%
unname()
m_post <- m_prior + AZ
u_post <- u_prior + BZ
m_post <- split(m_post, field_marker)
m <- as.vector(unlist(sapply(m_post, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u_post <- split(u_post, field_marker)
u <- as.vector(unlist(sapply(u_post, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
ratio <- (log(m) - log(u)) %>%
rep(., P) %>%
matrix(., nrow = P, byrow = TRUE)
unique_weights <- exp(rowSums(ratio * unique_patterns, na.rm = TRUE))
hash_weights <- lapply(counts_by_rec, function(x){
x * unique_weights
})
pi <- rbeta(1, L + alpha, n2 - L + beta)
alpha <- 1
beta <- 1
pi <- rbeta(1, L + alpha, n2 - L + beta)
for(j in 1:n2){
if(Z[j] > 0){
L <- L - 1
}
Z[j] <- sample(candidates_P, 1,
prob = c(1 - pi, hash_weights[[j]] * pi / n1))
if(Z[j] > 0){
index <- ceiling(runif(1) * counts_by_rec[[j]][Z[j]])
Z.SAMPS[j, s] <- hash_to_file_1[[j]][[Z[j]]][index]
L <- L + 1
}
}
which(is.na(Z.SAMPS[, 1]))
look <- which(is.na(Z.SAMPS[, 1]))
lookZ <- Z[look]
lookZ
counts_by_rec[[look[1]]]
counts_by_rec[[look[1]]] %>%
View()
.
counts_by_rec[[look[1]]] %>% sum()
counts_by_rec[[look[1]]][counts_by_rec[[look[1]]]>0]
which(counts_by_rec[[look[1]]] > 0)
lookZ
View(hash_to_file_1[[look[1]]])
counts_by_rec[[look[1]]][lookZ[1]]
for(j in 1:n2){
if(Z[j] > 0){
L <- L - 1
}
Z[j] <- sample(candidates_P, 1,
prob = c(1 - pi, hash_weights[[j]] * pi / n1))
if(Z[j] > 0){
#index <- ceiling(runif(1) * counts_by_rec[[j]][Z[j]]) #Causes issue with SEI
index <- ceiling(runif(1) * length(hash_to_file_1[[j]][[Z[j]]])
Z.SAMPS[j, s] <- hash_to_file_1[[j]][[Z[j]]][index]
for(j in 1:n2){
if(Z[j] > 0){
L <- L - 1
}
Z[j] <- sample(candidates_P, 1,
prob = c(1 - pi, hash_weights[[j]] * pi / n1))
if(Z[j] > 0){
#index <- ceiling(runif(1) * counts_by_rec[[j]][Z[j]]) #Causes issue with SEI
index <- ceiling(runif(1) * length(hash_to_file_1[[j]][[Z[j]]]))
Z.SAMPS[j, s] <- hash_to_file_1[[j]][[Z[j]]][index]
L <- L + 1
}
}
look <- which(is.na(Z.SAMPS[, 1]))
lookZ <- Z[look]
look <- which(is.na(Z.SAMPS[, 1]))
for(j in 1:n2){
if(Z[j] > 0){
L <- L - 1
}
Z[j] <- sample(candidates_P, 1,
prob = c(1 - pi, hash_weights[[j]] * pi / n1))
if(Z[j] > 0){
#index <- ceiling(runif(1) * counts_by_rec[[j]][Z[j]]) #Causes issue with SEI
index <- ceiling(runif(1) * length(hash_to_file_1[[j]][[Z[j]]]))
Z.SAMPS[j, s] <- hash_to_file_1[[j]][[Z[j]]][index]
L <- L + 1
}
}
Z
look <- which(is.na(Z.SAMPS[, 1]))
lookZ <- Z[look]
Z.SAMPS <- matrix(0, nrow = n2, ncol = S)
for(j in 1:n2){
if(Z[j] > 0){
L <- L - 1
}
Z[j] <- sample(candidates_P, 1,
prob = c(1 - pi, hash_weights[[j]] * pi / n1))
if(Z[j] > 0){
#index <- ceiling(runif(1) * counts_by_rec[[j]][Z[j]]) #Causes issue with SEI
index <- ceiling(runif(1) * length(hash_to_file_1[[j]][[Z[j]]]))
Z.SAMPS[j, s] <- hash_to_file_1[[j]][[Z[j]]][index]
L <- L + 1
}
}
look <- which(is.na(Z.SAMPS[, 1]))
lookZ <- Z[look]
detach("package:fabldev", unload = TRUE)
devtools::install_github("briankundinger/fabldev")
chain <- gibbs_efficient(hash, S = S, burn = burn)
library(fabldev)
chain <- gibbs_efficient(hash, S = S, burn = burn)
library(fabldev)
library(ggplot2)
n1 <- 50
n2 <- 50
overlap <- n2/2
S = 50
burn = S * .1
show_progress <- T
fast = F
R <- NULL
all_patterns <- FALSE
threshold = 1e-5
tmax = 1000
fixed_iterations = NULL
b_init = TRUE
B = min(1000, hash$n2)
k = 1
tau = 1
seed = 0
fixed_u = F
m <- c(.05, .95, .05, .95, .05, .95, .05, .95, .05, .95)
u <- c(.99, .01, .99, .01,
1 - 1/30, 1/30, 1 - 1/12, 1/12, 1 - 1/15, 1/15)
levels <- c(2, 2, 2, 2, 2)
S <- 1000; burn <- S * .1
m_prior <- u_prior <- rep(1, length(m))
alpha <- beta <- 1
cd <- simulate_comparisons(m, u, levels, n1, n2, overlap)
hash <- hash_comparisons(cd)
Ztrue <- cd$Ztrue
chain <- gibbs_efficient(hash, S = S, burn = burn)
S <- 100; burn <- S * .1
chain <- gibbs_base(cd, S = S, burn = burn)
Z_chain <- chain$Z
apply(Z_chain, 1, function(x){
table(x)
})
apply(Z_chain, 1, function(x){
table(x)/length(x)
})
threshold <- .5
samps <- ncol(Z_chain)
probs <- apply(Z_chain, 1, function(x){
table(x)/samps
})
lapply(probs, function(x){
x[x>threshold]
})
lapply(probs, function(x){
names(x[x>threshold])
})
names(x[x>threshold]) %>%
as.numeric
lapply(probs, function(x){
names(x[x>threshold]) %>%
as.numeric
})
sapply(probs, function(x){
names(x[x>threshold]) %>%
as.numeric
})
thing <- c(.4, .4, .2)
names(thing) <- c("1", "2", "3")
names(thing[thing>threshold]) %>%
as.numeric
probs[[50]] <- thing
probs <- apply(Z_chain, 1, function(x){
table(x)/samps
})
probs
probs[[50]] <- thing
sapply(probs, function(x){
names(x[x>threshold]) %>%
as.numeric
})
sapply(probs, function(x){
match <- names(x[x>threshold]) %>%
as.numeric
if(length(match) == 0){
match <- 51
}
match
})
samps <- ncol(Z_chain)
probs <- apply(Z_chain, 1, function(x){
table(x)/samps
})
sapply(probs, function(x){
max(x)
})
sapply(probs, function(x){
names(max(x))
})
sapply(probs, function(x){
which.max(x)
})
sapply(probs[1], function(x){
which.max(x)
})
sapply(probs[2], function(x){
which.max(x)
})
names(which.max(x))
sapply(probs[2], function(x){
names(which.max(x))
})
sapply(probs, function(x){
names(which.max(x))
})
maxProbOption <- sapply(probs, function(x){
names(which.max(x))
})
probmaxProbOption <- sapply(probs, function(x){
max(x)
})
probmaxProbOption
maxProbOption <- sapply(probs, function(x){
names(which.max(x))
}) %>%
as.numeric()
n2
Z_hat <- rep(0, n2)
maxProbOption <- sapply(probs, function(x){
names(which.max(x))
}) %>%
as.numeric()
probmaxProbOption <- sapply(probs, function(x){
max(x)
})
names(probs)
probs <- apply(Z_chain, 1, function(x){
table(x)/samps
})
probs
lapply(probs, names)
probNoLink <- sapply(probs, function(x){
1 - sum(x[names(x) != n1])
})
probNoLink
n1
probNoLink <- sapply(probs, function(x){
1 - sum(x[names(x) != n1 + 1])
})
probNoLink
chain$Z
devtools::load_all(".")
results <- estimate_links(chain$Z, n1)
devtools::load_all(".")
results <- estimate_links(chain$Z, n1)
results
