#                     prob = NA))
# } else {
#
# return(data.frame(id_2 = x,
#            id_1 = matching_records,
#            prob = matching_probs))
}) %>%
do.call(rbind, .) %>%
filter(!is.na(prob))
View(matches)
x = 2
counts <- combination_counts[[x]] %>% unlist()
probs <- pattern_weights * counts/ C[x]
probs_combined <- sapply(1:P, function(y){
sum(probs[pattern_finder[[y]]])
})
matching_patterns <- which(probs_combined > tholdLink)
matching_probs <- probs_combined[matching_patterns]
matching_records <- lapply(matching_patterns, function(y){
records <- hash$hash_to_file_1[[x]][[y]]
prob <- rep(probs_combined[x], length(records))
if(length(records) == 0){
return(data.frame(id_2 = x,
id_1 = NA,
prob = NA))
} else {
return(data.frame(id_2 = x,
id_1 = records,
prob = prob))
}
}) %>%
do.call(rbind, .)
View(matching_records)
matching_patterns
y = 1
hash$hash_to_file_1[[x]][[y]]
matching_records <- lapply(matching_patterns, function(y){
records <- hash$hash_to_file_1[[x]][[y]]
prob <- rep(probs_combined[y], length(records))
if(length(records) == 0){
return(data.frame(id_2 = x,
id_1 = NA,
prob = NA))
} else {
return(data.frame(id_2 = x,
id_1 = records,
prob = prob))
}
}) %>%
do.call(rbind, .)
View(matching_records)
matches <- lapply(1:n2, function(x){
counts <- combination_counts[[x]] %>% unlist()
probs <- pattern_weights * counts/ C[x]
probs_combined <- sapply(1:P, function(y){
sum(probs[pattern_finder[[y]]])
})
matching_patterns <- which(probs_combined > tholdLink)
matching_probs <- probs_combined[matching_patterns]
matching_records <- lapply(matching_patterns, function(y){
records <- hash$hash_to_file_1[[x]][[y]]
prob <- rep(probs_combined[y], length(records))
if(length(records) == 0){
return(data.frame(id_2 = x,
id_1 = NA,
prob = NA))
} else {
return(data.frame(id_2 = x,
id_1 = records,
prob = prob))
}
}) %>%
do.call(rbind, .)
# if(length(matching_records) == 0){
#   return(data.frame(id_2 = x,
#                     id_1 = NA,
#                     prob = NA))
# } else {
#
# return(data.frame(id_2 = x,
#            id_1 = matching_records,
#            prob = matching_probs))
}) %>%
do.call(rbind, .) %>%
filter(!is.na(prob))
matches <- lapply(1:n2, function(x){
counts <- combination_counts[[x]] %>% unlist()
probs <- pattern_weights * counts/ C[x]
probs_combined <- sapply(1:P, function(y){
sum(probs[pattern_finder[[y]]])
})
matching_patterns <- which(probs_combined > tholdLink)
matching_probs <- probs_combined[matching_patterns]
matching_records <- lapply(matching_patterns, function(y){
records <- hash$hash_to_file_1[[x]][[y]]
prob <- rep(probs_combined[y], length(records))
if(length(records) == 0){
return(data.frame(id_2 = x,
id_1 = NA,
prob = NA))
} else {
return(data.frame(id_2 = x,
id_1 = records,
prob = prob))
}
}) %>%
do.call(rbind, .)
# if(length(matching_records) == 0){
#   return(data.frame(id_2 = x,
#                     id_1 = NA,
#                     prob = NA))
# } else {
#
# return(data.frame(id_2 = x,
#            id_1 = matching_records,
#            prob = matching_probs))
}) %>%
do.call(rbind, .) %>%
filter(!is.na(prob)) %>%
arrange(id_2, id_1)
View(matches)
devtools::load_all(".")
results <- vi_estimate_links_mm(out, hash_mm)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
chain <- gibbs_efficient_mm(hash, S = S, burn = burn)
hash <- hash_comparisons(cd)
chain <- gibbs_efficient_mm(hash, S = S, burn = burn)
results <- estimate_links_mm(chain$Z, n1)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
out <- vi_efficient_mm(hash_mm, fixed_iterations = 100, use_elbo = F)
results <- vi_estimate_links_mm(out, hash_mm)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
# size_of_sim <- 8
# n1 <- 2^size_of_sim
# n2 <- 2^size_of_sim
# overlap <- 2^((k-1):(k - 1 - layers))
n1 <- 50
n2 <- 50
overlap <- c(15, 10, 5)
S = 100
burn = S * .1
tmax <- 50
b_init <- TRUE
show_progress <- T
fast = F
R <- NULL
all_patterns <- FALSE
m <- c(.05, .95, .05, .95, .05, .95, .05, .95, .05, .95)
u <- c(.99, .01, .99, .01,
1 - 1/30, 1/30, 1 - 1/12, 1/12, 1 - 1/15, 1/15)
levels <- c(2, 2, 2, 2, 2)
m_prior <- u_prior <- rep(1, length(m))
alpha <- beta <- 1
cd <- simulate_comparisons_mm(m, u, levels, n1, n2, overlap)
hash <- hash_comparisons(cd)
hash_mm <- hash_comparisons_mm(cd, max_K = length(overlap))
#hash <- hash_mm
Z_true <- cd$Z_true
chain <- gibbs_efficient(hash, S = S, burn = burn)
results <- estimate_links(chain$Z, n1)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
chain <- gibbs_efficient_mm(hash, S = S, burn = burn)
results <- estimate_links_mm(chain$Z, n1)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
out <- vi_efficient(hash)
results <- vi_estimate_links(out, hash)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
out <- vi_efficient_mm(hash_mm, fixed_iterations = 100, use_elbo = F)
results <- vi_estimate_links_mm(out, hash_mm)
eval <- evaluate_links_mm(results$Z_hat, Z_true, n1)
eval
by_names <- sapply(1:max_K, function(x){
paste("X", x)
})
max_K = 3
by_names <- sapply(1:max_K, function(x){
paste("X", x)
})
by_names <- sapply(1:max_K, function(x){
paste0("X", x)
})
indicators <- cd[[1]]
N <- dim(indicators)[1]
n1 <- cd[[2]]
n2 <- cd[[3]]
levels <- cd[[4]]
fields <- seq_along(cd[[4]])
field_marker <- sapply(fields, function(x){
rep(x, cd[[4]][x])
}) %>%
unlist(.) %>%
as.vector(.)
ids <- expand.grid(1:n1, 1:n2)
rec1 <- ids[,1]
rec2 <- ids[,2]
Lf_vec<- (levels) %>%
c(0, .) %>%
cumsum()
hash_vals <- purrr::imap(cd[[4]], ~hash_field(.x, .y, Lf_vec)) %>%
unlist()
hash <- sweep(indicators, 2, hash_vals, "*") %>%
rowSums() + 1
if(all_patterns == TRUE){
unique_patterns <- possible_patterns_sadinle(levels)
unique_hashed <- sweep(unique_patterns, 2, hash_vals, "*") %>%
rowSums() + 1
P <- dim(unique_patterns)[1]
hash_id <- match(hash, unique_hashed) %>%
factor(levels = 1:P)
} else {
unique_hashed <- unique(hash)
P <- length(unique_hashed)
hash_id <- match(hash, unique_hashed) %>%
factor(levels = 1:P)
unique_patterns <- indicators[!duplicated(hash_id), ]
}
temp <- data.frame(indicators, rec1, rec2, hash_id)
total_counts <- temp %>%
group_by(hash_id, .drop = F) %>%
count() %>%
pull()
column_names <- sapply(seq_len(max_K), function(x){
paste0("X", x)
})
pattern_lookup <- expand.grid(1:P, 1:n2) %>%
data.frame() %>%
setNames(., c("hash_id", "rec2"))
pattern_combinations <- lapply(seq_len(max_K), function(k){
do.call(expand.grid, rep(list(1:P), k)) %>%
data.frame() %>%
setNames(column_names[1:k])
})
pattern_combinations_all <- do.call(plyr::rbind.fill, pattern_combinations) %>%
data.frame() %>%
mutate(rn = row_number())
K_marker <- apply(pattern_combinations_all, 1, function(x){
sum(!is.na(x)) - 1
})
pattern_finder <- lapply(1:P, function(y){
pattern_combinations_all %>%
filter(if_any(starts_with("X"), ~.x == y )) %>%
select(rn) %>%
pull()
})
combination_ohe <- lapply(seq_len(max_K), function(k){
apply(pattern_combinations[[k]], 1, function(x){
if(k == 1){
unique_patterns[x, ]
} else {
unique_patterns[unlist(x), ] %>%
colSums()
}
}) %>%
t()
})
temp2 <- temp %>%
group_split(rec2)
by_names <- sapply(1:max_K, function(x){
paste0("X", x)
})
combination_counts <- lapply(temp2, function(y){
combo_counts <- lapply(seq_len(max_K), function(k){
combo_counts <- y$hash_id %>%
as.numeric() %>%
combn(k) %>%
t() %>%
data.frame() %>%
setNames(column_names[1:k]) %>%
group_by_all() %>%
count()
full_set <- left_join(pattern_combinations[[k]],
combo_counts,
by = by_names)
full_set$n[is.na(full_set$n)] <- 0
full_set$n
})
combo_counts
})
combination_counts <- lapply(temp2, function(y){
combo_counts <- lapply(seq_len(max_K), function(k){
combo_counts <- y$hash_id %>%
as.numeric() %>%
combn(k) %>%
t() %>%
data.frame() %>%
setNames(column_names[1:k]) %>%
group_by_all() %>%
count()
by_names <- sapply(1:k, function(x){
paste0("X", x)
})
full_set <- left_join(pattern_combinations[[k]],
combo_counts)
full_set$n[is.na(full_set$n)] <- 0
full_set$n
})
combo_counts
})
combination_counts <- lapply(temp2, function(y){
combo_counts <- lapply(seq_len(max_K), function(k){
combo_counts <- y$hash_id %>%
as.numeric() %>%
combn(k) %>%
t() %>%
data.frame() %>%
setNames(column_names[1:k]) %>%
group_by_all() %>%
count()
by_names <- sapply(1:k, function(x){
paste0("X", x)
})
full_set <- left_join(pattern_combinations[[k]],
combo_counts,
by = by_names)
full_set$n[is.na(full_set$n)] <- 0
full_set$n
})
combo_counts
})
devtools::load_all(".")
n1 <- 50
n2 <- 50
overlap <- n2/2
S = 50
burn = S * .1
show_progress <- T
fast = F
R <- NULL
all_patterns <- FALSE
m <- c(.05, .95, .05, .95, .05, .95, .05, .95, .05, .95)
u <- c(.99, .01, .99, .01,
1 - 1/30, 1/30, 1 - 1/12, 1/12, 1 - 1/15, 1/15)
levels <- c(2, 2, 2, 2, 2)
S <- 1000; burn <- S * .1
m_prior <- u_prior <- rep(1, length(m))
alpha <- beta <- 1
cd <- simulate_comparisons(m, u, levels, n1, n2, overlap)
hash <- hash_comparisons(cd)
Ztrue <- cd$Ztrue
seed = 0
reject_iter = round(hash$n2/length(hash$total_counts))
set.seed(seed)
n1 <- hash$n1
n2 <- hash$n2
field_marker <- hash$field_marker
unique_patterns <- hash$ohe
pattern_counts <- hash$total_counts
P <- nrow(unique_patterns)
counts_by_rec <- hash$pattern_counts_by_record
hash_to_file_1 <-hash$hash_to_file_1
pair_to_pattern <- hash$pair_to_pattern
#candidates_P <- 1:(P+1)
candidates_P <- 0:P
Z.SAMPS <- matrix(NA, nrow = n2, ncol = S)
M.SAMPS <- matrix(NA, nrow = length(field_marker), ncol = S)
U.SAMPS <- matrix(NA, nrow = length(field_marker), ncol = S)
L.SAMPS <- vector(length = S)
Z <- rep(0, n2)
Z_pattern <- rep(0, n2)
Z_inv <- rep(0, n1)
L <- 0
m <- u <- rep(0, length(field_marker))
matches <- rep(0, P)
#already_matched <- rep(0, n1)
#set.seed(1)
AZ <- sweep(unique_patterns, MARGIN = 1, STAT = matches, FUN = "*") %>%
colSums() %>%
unname()
nonmatches <- pattern_counts - matches
BZ <- sweep(unique_patterns, MARGIN = 1, STAT = nonmatches, FUN = "*") %>%
colSums() %>%
unname()
m_post <- m_prior + AZ
u_post <- u_prior + BZ
m_post <- split(m_post, field_marker)
m <- as.vector(unlist(sapply(m_post, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u_post <- split(u_post, field_marker)
u <- as.vector(unlist(sapply(u_post, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
ratio <- (log(m) - log(u)) %>%
rep(., P) %>%
matrix(., nrow = P, byrow = TRUE)
unique_weights <- exp(rowSums(ratio * unique_patterns, na.rm = TRUE))
for(j in sample(1:n2)){
if(Z[j] > 0){
L <- L - 1
Z_inv[Z[j]] <- 0
}
Z[j] <- 0
hash_weights <- counts_by_rec[[j]] * unique_weights
probs <- c((n1 - L) * (n2 - L + beta) / (L + alpha),
hash_weights)
# probs <- c((n1 - L) * (n2 - L - 1 + beta) / (L + alpha),
#            hash_weights) # You don't need the -1 here, since you updated L above
flag <- 1
iter <- 0
while(flag == 1){
pattern <- sample(candidates_P, 1, prob = probs)
if(pattern == 0){
Z[j] <- 0
flag <- 0
}
else{
index <- ceiling(runif(1) * counts_by_rec[[j]][pattern])
i <- hash_to_file_1[[j]][[pattern]][index]
if(Z_inv[i] == 0){
Z[j] <- i
flag <- 0
}
}
iter <- iter + 1
if(iter == reject_iter){
n_current <- counts_by_rec[[j]]
for(k in 1:n2){
if(Z[k] > 0){
ind <- pair_to_pattern[[j]][Z[k]]
n_current[ind] <- n_current[ind] -1
}
}
temp_weights <- n_current * unique_weights
probs <- c((n1 - L) * (n2 - L - 1 + beta) / (L + alpha),
temp_weights)
pattern <- sample(candidates_P, 1, prob = probs)
if(pattern == 0){
Z[j] <- 0
}
else{
flag_2 <- 1
npj <- counts_by_rec[[j]][pattern]
while(flag_2 == 1){
index <- ceiling(runif(1) * npj)
i <- hash_to_file_1[[j]][[pattern]][index]
if(Z_inv[i] == 0){
Z[j] <- i
flag_2 <- 0
}
}
}
flag <- 0
}
}
if(Z[j] > 0){
L <- L + 1
Z_inv[Z[j]] <- 1
}
}
hash_matches <- factor(Z_pattern, levels = 0:P)
df <- data.frame(hash_matches)
matches <- df %>%
group_by(hash_matches, .drop = F) %>%
count() %>%
filter(hash_matches != 0) %>%
pull()
AZ <- sweep(unique_patterns, MARGIN = 1, STAT = matches, FUN = "*") %>%
colSums() %>%
unname()
nonmatches <- pattern_counts - matches
BZ <- sweep(unique_patterns, MARGIN = 1, STAT = nonmatches, FUN = "*") %>%
colSums() %>%
unname()
m_post <- m_prior + AZ
u_post <- u_prior + BZ
m_post <- split(m_post, field_marker)
m <- as.vector(unlist(sapply(m_post, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
u_post <- split(u_post, field_marker)
u <- as.vector(unlist(sapply(u_post, function(x){
prob <- MCMCpack::rdirichlet(1, x)
prob/sum(prob)
})))
ratio <- (log(m) - log(u)) %>%
rep(., P) %>%
matrix(., nrow = P, byrow = TRUE)
unique_weights <- exp(rowSums(ratio * unique_patterns, na.rm = TRUE))
j = 1
L
Z[j]
if(Z[j] > 0){
L <- L - 1
Z_inv[Z[j]] <- 0
}
Z[j] <- 0
hash_weights <- counts_by_rec[[j]] * unique_weights
probs <- c((n1 - L) * (n2 - L - 1 + beta) / (L + alpha),
hash_weights)
flag <- 1
iter <- 0
pattern <- sample(candidates_P, 1, prob = probs)
ceiling(runif(1) * counts_by_rec[[j]][pattern])
counts_by_rec[[j]]
counts_by_rec[[j]][pattern]
index <- ceiling(runif(1) * counts_by_rec[[j]][pattern])
i <- hash_to_file_1[[j]][[pattern]][index]
reject_iter
k
k = 2
j
pair_to_pattern[[j]]
pair_to_pattern[[j]][Z[k]]
